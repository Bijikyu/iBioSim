package sbol;

import java.net.URI;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.prefs.Preferences;

import javax.swing.JOptionPane;

import main.Gui;

import org.sbml.libsbml.ASTNode;
import org.sbml.libsbml.CompModelPlugin;
import org.sbml.libsbml.CompSBMLDocumentPlugin;
import org.sbml.libsbml.CompSBasePlugin;
import org.sbml.libsbml.ExternalModelDefinition;
import org.sbml.libsbml.KineticLaw;
import org.sbml.libsbml.Model;
import org.sbml.libsbml.Reaction;
import org.sbml.libsbml.ReplacedBy;
import org.sbml.libsbml.ReplacedElement;
import org.sbml.libsbml.Rule;
import org.sbml.libsbml.SBMLDocument;
import org.sbml.libsbml.Species;
import org.sbml.libsbml.Submodel;
import org.sbolstandard.core.DnaComponent;

import biomodel.annotation.AnnotationUtility;
import biomodel.annotation.SBOLAnnotation;
import biomodel.network.Influence;
import biomodel.parser.BioModel;
import biomodel.parser.GCMParser;

public class SBOLSynthesisGraph {

	private LinkedHashMap<String, SBOLSynthesisNode> synMap;
	private Set<SBOLSynthesisNode> startNodes = new HashSet<SBOLSynthesisNode>();
	private boolean containsSBOL = false;
	private boolean isLinear = false;
	
	public SBOLSynthesisGraph(BioModel biomodel) {
		synMap = new LinkedHashMap<String, SBOLSynthesisNode>(); // initialize map of model element meta IDs to synthesis nodes
		HashMap<String, ArrayList<Influence>> complexMap = new HashMap<String, ArrayList<Influence>>(); // initialize map of species meta IDs to complex influences 
		HashMap<String, Set<String>> paramInputMap = new HashMap<String, Set<String>>(); // initialize map of parameters to meta IDs for reactions in which they appear
		HashMap<String, Set<String>> paramOutputMap = new HashMap<String, Set<String>>(); // initialize map of parameters to meta IDs for rules in which they're outputs
		HashMap<String, String> speciesMetaMap = new HashMap<String, String>(); // initialize map of species IDs to meta IDs
		SBMLDocument sbmlDoc;
		if (detectSBOLReplacements(biomodel)) {
//			Preferences biosimrc = Preferences.userRoot();
//			if (biosimrc.get("biosim.general.flatten", "").equals("libsbml")) 
//				sbmlDoc = biomodel.newFlattenModel();
//			else
//				sbmlDoc = flattenSubModelsWithSBOLReplacements(biomodel);
			sbmlDoc = biomodel.flattenModel();
		} else
			sbmlDoc = biomodel.getSBMLDocument();
		Model sbmlModel = sbmlDoc.getModel();
		for (long i = 0; i < sbmlModel.getNumSpecies(); i++) {
			Species sbmlSpecies = sbmlModel.getSpecies(i);
			speciesMetaMap.put(sbmlSpecies.getId(), sbmlSpecies.getMetaId());
		}

		// Create synthesis nodes for components (submodels)
		// Must come before parseSpeciesSbol() since latter connects nodes for species to nodes for submodels
		if (sbmlDoc.isPackageEnabled("comp"))
			parseSubModelSBOL(biomodel, sbmlDoc);

		// Create and connect synthesis nodes for species and promoters
		// Note that all non-promoter species must be parsed first since parsePromoterSbol may refer to them
		// when connecting synthesis nodes
		parseSpeciesSbol(biomodel, sbmlModel, complexMap, speciesMetaMap);
		parsePromoterSbol(sbmlModel, speciesMetaMap);

		// Create and connect synthesis nodes for reactions not auto-generated by iBioSim
		parseReactionSbol(sbmlModel, speciesMetaMap, paramInputMap);

		// Create and connect synthesis nodes for rules
		parseRuleSbol(sbmlModel, speciesMetaMap, paramInputMap, paramOutputMap);

		// Finishes connecting synthesis nodes in accordance with various maps (see above)
		// if no SBOL detected, then removes placeholder URI for iBioSim composite component instead
		if (containsSBOL) 
			connectMappedSynthesisNodes(complexMap, paramInputMap, paramOutputMap);
		
	}
	
	private boolean detectSBOLReplacements(BioModel biomodel) {
		CompModelPlugin compSBMLModel = biomodel.getSBMLCompModel();
		CompSBMLDocumentPlugin compSBMLDoc = biomodel.getSBMLComp();
		for (long i = 0; i < compSBMLModel.getNumSubmodels(); i++) {
			Submodel submodel = compSBMLModel.getSubmodel(i);
			if (submodel.getNumDeletions() > 0) {
				String subSBMLFileID = compSBMLDoc.getExternalModelDefinition(submodel.getModelRef()).getSource().replace("file://","").replace("file:","").replace(".gcm",".xml");
				BioModel subBioModel = new BioModel(biomodel.getPath());
				subBioModel.load(subSBMLFileID);
				Model subSBMLModel = subBioModel.getSBMLDocument().getModel();
				CompModelPlugin subCompSBMLModel = subBioModel.getSBMLCompModel();
				for (long j = 0; j < submodel.getNumDeletions(); j++) {
					String speciesID = subCompSBMLModel.getPort(submodel.getDeletion(j).getPortRef()).getIdRef();
					if (AnnotationUtility.parseSBOLAnnotation(subSBMLModel.getSpecies(speciesID)).size() > 0) {
						return true;
					}
				}
			}
		}
		Model sbmlModel = biomodel.getSBMLDocument().getModel();
		for (long i = 0; i < sbmlModel.getNumSpecies(); i++) {
			CompSBasePlugin compSBMLSpecies = (CompSBasePlugin) sbmlModel.getSpecies(i).getPlugin("comp");
			for (long j = 0; j < compSBMLSpecies.getNumReplacedElements(); j++) {
				ReplacedElement replacement = compSBMLSpecies.getReplacedElement(j);
				if (AnnotationUtility.parseSBOLAnnotation(sbmlModel.getSpecies(i)).size() > 0) 
					return true;
				else {
					Submodel submodel = compSBMLModel.getSubmodel(replacement.getSubmodelRef());
					String subSBMLFileID = compSBMLDoc.getExternalModelDefinition(submodel.getModelRef()).getSource().replace("file://","").replace("file:","").replace(".gcm",".xml");
					BioModel subBioModel = new BioModel(biomodel.getPath());
					subBioModel.load(subSBMLFileID);
					CompModelPlugin subCompSBMLModel = subBioModel.getSBMLCompModel();
					String speciesID = subCompSBMLModel.getPort(replacement.getPortRef()).getIdRef();
					Model subSBMLModel = subBioModel.getSBMLDocument().getModel();
					if (AnnotationUtility.parseSBOLAnnotation(subSBMLModel.getSpecies(speciesID)).size() > 0) 
						return true;
				}
			}
		}
		return false;
	}
	
	// Only flattens submodels with SBOL-annotated elements that are to be replaced/deleted
	// or with elements that will be replaced by SBOL-annotated elements
	private SBMLDocument flattenSubModelsWithSBOLReplacements(BioModel biomodel) {
		Set<String> flatteningSubModelIDs;
		do {
			flatteningSubModelIDs = identifySubModelsWithSBOLReplacements(biomodel);
			for (String subModelID : flatteningSubModelIDs) {
				biomodel = biomodel.partiallyFlattenModel(subModelID);
			}
			Model sbmlModel = biomodel.getSBMLDocument().getModel();
			for (long i = 0; i < sbmlModel.getNumSpecies(); i++) {
				CompSBasePlugin compSBMLSpecies = (CompSBasePlugin) sbmlModel.getSpecies(i).getPlugin("comp");
				for (long j = compSBMLSpecies.getNumReplacedElements() - 1; j >= 0; j--) {
					ReplacedElement replacement = compSBMLSpecies.getReplacedElement(j);
					if (flatteningSubModelIDs.contains(replacement.getSubmodelRef()))
						replacement.removeFromParentAndDelete();
				}
			}
			CompModelPlugin compSBMLModel = biomodel.getSBMLCompModel();
			for (String subModelID : flatteningSubModelIDs)
				compSBMLModel.getSubmodel(subModelID).removeFromParentAndDelete();
			CompSBMLDocumentPlugin compSBMLDoc = biomodel.getSBMLComp();
			Set<String> remainingModelRefs = new HashSet<String>();
			for (long i = 0; i < compSBMLModel.getNumSubmodels(); i++)
				remainingModelRefs.add(compSBMLModel.getSubmodel(i).getModelRef());
			for (long i = compSBMLDoc.getNumExternalModelDefinitions() - 1; i >= 0; i--) {
				ExternalModelDefinition extDef = compSBMLDoc.getExternalModelDefinition(i);
				if (!remainingModelRefs.contains(extDef.getId()))
					extDef.removeFromParentAndDelete();
			}
		} while(biomodel.getSBMLCompModel().getNumSubmodels() > 0 && flatteningSubModelIDs.size() > 0);
		return biomodel.getSBMLDocument();
	}
	
	private Set<String> identifySubModelsWithSBOLReplacements(BioModel biomodel) {
		Set<String> subModelIDs = new HashSet<String>();
		CompModelPlugin compSBMLModel = biomodel.getSBMLCompModel();
		CompSBMLDocumentPlugin compSBMLDoc = biomodel.getSBMLComp();
		for (long i = 0; i < compSBMLModel.getNumSubmodels(); i++) {
			Submodel submodel = compSBMLModel.getSubmodel(i);
			if (submodel.getNumDeletions() > 0) {
				String subSBMLFileID = compSBMLDoc.getExternalModelDefinition(submodel.getModelRef()).getSource().replace("file://","").replace("file:","").replace(".gcm",".xml");
				BioModel subBioModel = new BioModel(biomodel.getPath());
				subBioModel.load(subSBMLFileID);
				Model subSBMLModel = subBioModel.getSBMLDocument().getModel();
				CompModelPlugin subCompSBMLModel = subBioModel.getSBMLCompModel();
				for (long j = 0; j < submodel.getNumDeletions(); j++) {
					String speciesID = subCompSBMLModel.getPort(submodel.getDeletion(j).getPortRef()).getIdRef();
					if (AnnotationUtility.parseSBOLAnnotation(subSBMLModel.getSpecies(speciesID)).size() > 0) {
						subModelIDs.add(submodel.getId());
						j = submodel.getNumDeletions();
					}
				}
			}
		}
		Model sbmlModel = biomodel.getSBMLDocument().getModel();
		for (long i = 0; i < sbmlModel.getNumSpecies(); i++) {
			CompSBasePlugin compSBMLSpecies = (CompSBasePlugin) sbmlModel.getSpecies(i).getPlugin("comp");
			for (long j = 0; j < compSBMLSpecies.getNumReplacedElements(); j++) {
				ReplacedElement replacement = compSBMLSpecies.getReplacedElement(j);
				if (AnnotationUtility.parseSBOLAnnotation(sbmlModel.getSpecies(i)).size() > 0) 
					subModelIDs.add(replacement.getSubmodelRef());
				else {
					Submodel submodel = compSBMLModel.getSubmodel(replacement.getSubmodelRef());
					String subSBMLFileID = compSBMLDoc.getExternalModelDefinition(submodel.getModelRef()).getSource().replace("file://","").replace("file:","").replace(".gcm",".xml");
					BioModel subBioModel = new BioModel(biomodel.getPath());
					subBioModel.load(subSBMLFileID);
					CompModelPlugin subCompSBMLModel = subBioModel.getSBMLCompModel();
					String speciesID = subCompSBMLModel.getPort(replacement.getPortRef()).getIdRef();
					Model subSBMLModel = subBioModel.getSBMLDocument().getModel();
					if (AnnotationUtility.parseSBOLAnnotation(subSBMLModel.getSpecies(speciesID)).size() > 0) 
						subModelIDs.add(replacement.getSubmodelRef());
				}
			}
		}
		return subModelIDs;
	}
	
	// Uses SBOL associated to submodel instantiation if present
	// Otherwise constructs SBOL synthesizer for submodel or uses SBOL associated to submodel itself
	private void parseSubModelSBOL(BioModel biomodel, SBMLDocument sbmlDoc) {
		CompModelPlugin sbmlCompModel = (CompModelPlugin) sbmlDoc.getModel().getPlugin("comp");
		CompSBMLDocumentPlugin compSBMLDoc = (CompSBMLDocumentPlugin) sbmlDoc.getPlugin("comp");
		for (long i = 0; i < sbmlCompModel.getNumSubmodels(); i++) {
			Submodel submodel = sbmlCompModel.getSubmodel(i);
			String subSBMLFileID = compSBMLDoc.getExternalModelDefinition(submodel.getModelRef()).getSource().replace("file://","").replace("file:","").replace(".gcm",".xml");
			BioModel subBioModel = new BioModel(biomodel.getPath());
			subBioModel.load(subSBMLFileID);
			Model sbmlSubModel = subBioModel.getSBMLDocument().getModel();

			SBOLSynthesisNode synNode;
			List<URI> sbolURIs = AnnotationUtility.parseSBOLAnnotation(submodel);
			if (sbolURIs.size() > 0) {
				synNode = new SBOLSynthesisNode(submodel.getId(), sbolURIs);
				containsSBOL = true;
			} else {
				sbolURIs = AnnotationUtility.parseSBOLAnnotation(sbmlSubModel);
				synNode = new SBOLSynthesisNode(submodel.getId(), sbolURIs);
				if (sbolURIs.size() > 0)
					containsSBOL = true; 
			}
			synMap.put(synNode.getID(), synNode);
		}
	}

	
	private void parseSpeciesSbol(BioModel biomodel, Model sbmlModel, 
			HashMap<String, ArrayList<Influence>> complexMap, HashMap<String, String> speciesMetaMap) {
		for (long i = 0; i < sbmlModel.getNumSpecies(); i++) {
			Species sbmlSpecies = sbmlModel.getSpecies(i);
			if (!BioModel.isPromoterSpecies(sbmlSpecies)) {
				// Create synthesis node corresponding to sbml species
				List<URI> sbolURIs = AnnotationUtility.parseSBOLAnnotation(sbmlSpecies);
				SBOLSynthesisNode synNode = new SBOLSynthesisNode(sbmlSpecies.getMetaId(), sbolURIs);

				synMap.put(synNode.getID(), synNode);
				// Determine if species belongs to a gcm component
				String component = "";
				String speciesId = sbmlSpecies.getId();
				if (sbmlSpecies.getId().contains("__")) {
					component = sbmlSpecies.getId().substring(0, sbmlSpecies.getId().lastIndexOf("__") + 2);
					speciesId = speciesId.substring(speciesId.lastIndexOf("__")+2);
				}
				// Build complex map for use in connecting synthesis nodes
				// Remove species complex formation reaction from sbml
				Reaction complexFormation = sbmlModel.getReaction(component + "Complex_" + speciesId);
				if (complexFormation != null) {
					for (long j = 0; j < complexFormation.getNumReactants(); j++) {
						Influence infl = new Influence();		
						String inputMetaID = speciesMetaMap.get(complexFormation.getReactant(j).getSpecies());
						String outputMetaID = speciesMetaMap.get(complexFormation.getProduct(0).getSpecies());
						infl.setInput(inputMetaID);
						//Maps complex species to complex formation influences for which they're outputs
						ArrayList<Influence> complexInfluences = null;
						if (complexMap.containsKey(outputMetaID)) {
							complexInfluences = complexMap.get(outputMetaID);
						} else { 
							complexInfluences = new ArrayList<Influence>();
							complexMap.put(outputMetaID, complexInfluences);
						}
						complexInfluences.add(infl);
					} 
				}
				// Connect synthesis nodes of species to nodes of components for which they're inputs/outputs
				if (sbmlModel.isPackageEnabled("comp")) {
					CompModelPlugin compSBMLModel = biomodel.getSBMLCompModel();
					CompSBMLDocumentPlugin compSBMLDoc = biomodel.getSBMLComp();
					CompSBasePlugin compSBMLSpecies = (CompSBasePlugin) sbmlSpecies.getPlugin("comp");
					for (long j = 0; j < compSBMLSpecies.getNumReplacedElements(); j++) {
						ReplacedElement replacement = compSBMLSpecies.getReplacedElement(j);
						Submodel submodel = compSBMLModel.getSubmodel(replacement.getSubmodelRef());
						String subSBMLFileID = compSBMLDoc.getExternalModelDefinition(submodel.getModelRef()).getSource().replace("file://","").replace("file:","").replace(".gcm",".xml");
						BioModel subBioModel = new BioModel(biomodel.getPath());
						subBioModel.load(subSBMLFileID);
						CompModelPlugin subCompSBMLModel = subBioModel.getSBMLCompModel();
						SBOLSynthesisNode modelSynNode = synMap.get(replacement.getSubmodelRef());
						if (BioModel.isInputPort(subCompSBMLModel.getPort(replacement.getPortRef())))
							synNode.addNextNode(modelSynNode);
						else if (BioModel.isOutputPort(subCompSBMLModel.getPort(replacement.getPortRef())))
							modelSynNode.addNextNode(synNode);
					}
					ReplacedBy replacedBy = compSBMLSpecies.getReplacedBy();
					if (replacedBy != null) {
						Submodel submodel = compSBMLModel.getSubmodel(replacedBy.getSubmodelRef());
						String subSBMLFileID = compSBMLDoc.getExternalModelDefinition(submodel.getModelRef()).getSource().replace("file://","").replace("file:","").replace(".gcm",".xml");
						BioModel subBioModel = new BioModel(biomodel.getPath());
						subBioModel.load(subSBMLFileID);
						CompModelPlugin subCompSBMLModel = subBioModel.getSBMLCompModel();
						SBOLSynthesisNode modelSynNode = synMap.get(replacedBy.getSubmodelRef());
						if (BioModel.isInputPort(subCompSBMLModel.getPort(replacedBy.getPortRef())))
							synNode.addNextNode(modelSynNode);
						else if (BioModel.isOutputPort(subCompSBMLModel.getPort(replacedBy.getPortRef())))
							modelSynNode.addNextNode(synNode);
					}
				}
				if (sbolURIs.size() > 0)
					containsSBOL = true;
			}
		}
	}
	
	private void parsePromoterSbol(Model sbmlModel, HashMap<String, String> speciesMetaMap) {
		for (long i = 0; i < sbmlModel.getNumSpecies(); i++) {
			Species sbmlSpecies = sbmlModel.getSpecies(i);
			if (BioModel.isPromoterSpecies(sbmlSpecies)) {
				// Create synthesis node corresponding to sbml promoter 
				List<URI> sbolURIs = AnnotationUtility.parseSBOLAnnotation(sbmlSpecies);
				SBOLSynthesisNode synNode = new SBOLSynthesisNode(sbmlSpecies.getMetaId(), sbolURIs);
				synMap.put(synNode.getID(), synNode);
				// Determine if promoter belongs to a component
				String component = "";
				String promoterId = sbmlSpecies.getId();
				if (sbmlSpecies.getId().contains("__")) {
					component = sbmlSpecies.getId().substring(0, sbmlSpecies.getId().lastIndexOf("__")+2);
					promoterId = promoterId.substring(promoterId.lastIndexOf("__")+2);
				}
				// Connect synthesis node for promoter to synthesis nodes for its products
				// Remove promoter production reaction from sbml
				Reaction production = sbmlModel.getModel().getReaction(component + "Production_" + promoterId);
				if (production != null) {
					for (long j = 0; j < production.getNumProducts(); j++) {
						String productMetaID = speciesMetaMap.get(production.getProduct(j).getSpecies());
						synNode.addNextNode(synMap.get(productMetaID));
					}
				}
				if (sbolURIs.size() > 0)
					containsSBOL = true;
			}
		}
	}
	
	private void parseReactionSbol(Model sbmlModel, HashMap<String, String> speciesMetaMap, 
			HashMap<String, Set<String>> paramInputMap) {
		for (long i = 0; i < sbmlModel.getNumReactions(); i++) {
			Reaction sbmlReaction = sbmlModel.getReaction(i);
			// Create synthesis node corresponding to sbml reaction
			List<URI> sbolURIs = AnnotationUtility.parseSBOLAnnotation(sbmlReaction);
			SBOLSynthesisNode synNode = new SBOLSynthesisNode(sbmlReaction.getMetaId(), sbolURIs);
			synMap.put(synNode.getID(), synNode);
			// Connect synthesis nodes for reactants, modifiers to synthesis node for reaction
			for (long j = 0; j < sbmlReaction.getNumReactants(); j++) {
				String reactantMetaID = speciesMetaMap.get(sbmlReaction.getReactant(j).getSpecies());
				synMap.get(reactantMetaID).addNextNode(synNode);
			}
			for (long j = 0; j < sbmlReaction.getNumModifiers(); j++) {
				String modifierMetaID = speciesMetaMap.get(sbmlReaction.getModifier(j).getSpecies());
				synMap.get(modifierMetaID).addNextNode(synNode);
			}
			// Connect synthesis node for reaction to synthesis nodes for its products
			for (long j = 0; j < sbmlReaction.getNumProducts(); j++) {
				String productMetaID = speciesMetaMap.get(sbmlReaction.getProduct(j).getSpecies());
				synNode.addNextNode(synMap.get(productMetaID));
			}
			// Map global parameters to reactions in which they appear
			KineticLaw kl = sbmlReaction.getKineticLaw();
			Set<String> localParams = new HashSet<String>();
			if (kl != null) {
				for (long j = 0; j < kl.getNumParameters(); j++) {
					localParams.add(kl.getParameter(j).getId());
				}
				for (String input : parseInputHelper(kl.getMath())) {
					if (!speciesMetaMap.containsKey(input) && !localParams.contains(input)) {
						if (!paramInputMap.containsKey(input))
							paramInputMap.put(input, new HashSet<String>());
							paramInputMap.get(input).add(sbmlReaction.getMetaId());
					}
				}
			}
			if (sbolURIs.size() > 0)
				containsSBOL = true;
		}
	}
	
	private void parseRuleSbol(Model sbmlModel, HashMap<String, String> speciesMetaMap, 
			HashMap<String, Set<String>> paramInputMap, HashMap<String, Set<String>> paramOutputMap) {
		for (long i = 0; i < sbmlModel.getNumRules(); i++) {
			Rule sbmlRule = sbmlModel.getRule(i);
			// Create synthesis node corresponding to sbml rule
			if (sbmlRule.isAssignment() || sbmlRule.isRate()) {
				List<URI> sbolURIs = AnnotationUtility.parseSBOLAnnotation(sbmlRule);
				SBOLSynthesisNode synNode = new SBOLSynthesisNode(sbmlRule.getMetaId(), sbolURIs);
				synMap.put(synNode.getID(), synNode);
				// Connect synthesis nodes for input species to synthesis node for rule
				// or maps input parameters to rules
				for (String input : parseInputHelper(sbmlRule.getMath())) {
					if (speciesMetaMap.containsKey(input))
						synMap.get(speciesMetaMap.get(input)).addNextNode(synNode);
					else {
						if (!paramInputMap.containsKey(input))
							paramInputMap.put(input, new HashSet<String>());
						paramInputMap.get(input).add(sbmlRule.getMetaId());
					}
				}
				// Connects synthesis node for rule to synthesis node for its output species
				// or maps output parameter to rule
				String output = sbmlRule.getVariable();
				if (output != null) {
					if (speciesMetaMap.containsKey(output))
						synNode.addNextNode(synMap.get(speciesMetaMap.get(output)));
					else {
						if (!paramOutputMap.containsKey(output))
							paramOutputMap.put(output, new HashSet<String>());
						paramOutputMap.get(output).add(sbmlRule.getMetaId());
					}
				}
				if (sbolURIs.size() > 0)
					containsSBOL = true;
			}
		}
	}
	
	private LinkedList<String> parseInputHelper(ASTNode astNode) {
		LinkedList<String> inputs = new LinkedList<String>();
		for (long i = 0; i < astNode.getNumChildren(); i++) {
			ASTNode childNode = astNode.getChild(i);
			if (!childNode.isOperator() && !childNode.isNumber())
				inputs.add(childNode.getName());
			inputs.addAll(parseInputHelper(childNode));
		}
		return inputs;
	}
	
	private void connectMappedSynthesisNodes(HashMap<String, ArrayList<Influence>> complexMap, 
			HashMap<String, Set<String>> paramInputMap, HashMap<String, Set<String>> paramOutputMap) {
		// Connect synthesis nodes for species that form complexes
		for (String complexId : complexMap.keySet())
			for (Influence infl : complexMap.get(complexId))
				synMap.get(infl.getInput()).addNextNode(synMap.get(complexId));
		// Connect synthesis nodes for rules to synthesis nodes for rules or reactions on the basis of shared parameters
		for (String param : paramInputMap.keySet())
			if (paramOutputMap.containsKey(param)) 
				for (String origin : paramOutputMap.get(param))
					for (String destination : paramInputMap.get(param))
						synMap.get(origin).addNextNode(synMap.get(destination));
	}
	
	public boolean loadDNAComponents(SBOLFileManager fileManager) {
		boolean error = false;
		for (SBOLSynthesisNode synNode : getNodes()) {
			List<URI> sbolURIs = synNode.getURIs();
			if (sbolURIs.size() > 0) {
				List<DnaComponent> dnaComps = new LinkedList<DnaComponent>();
				for (URI sbolURI : sbolURIs) {
					DnaComponent dnaComp = fileManager.resolveURI(sbolURI);
					if (dnaComp == null)
						error = true;
					else if (!error)
						dnaComps.add(dnaComp);
				}
				if (!error)
					synNode.setDNAComponents(dnaComps);
			}
		}
		return (!error);
	}
	
	public void cutGraph(Set<String> startTypes) {
		cutNodesWithStartComponents(startTypes);
		selectStartNodes();
		cutCycles();
	}
	
//	private void cutNodesWithStartComponents(Set<String> startTypes) {
//		int idIndex = 0;
//		Set<SBOLSynthesisNode> cutNodes = new HashSet<SBOLSynthesisNode>();
//		for (SBOLSynthesisNode synNode : synMap.values()) {
//			List<SBOLSynthesisNode> emptyEdgeNodes = new LinkedList<SBOLSynthesisNode>();
//			for (SBOLSynthesisNode nextNode : synNode.getNextNodes()) {
//				List<DnaComponent> edgeComponents = new LinkedList<DnaComponent>();
//				int cutIndex = 0;
//				List<DnaComponent> dnaComps = nextNode.getDNAComponents();
//				for (int i = 0; i <= dnaComps.size(); i++) {
//					if (i == dnaComps.size()) 
//						if (cutIndex == 0) 
//							edgeComponents.addAll(dnaComps.subList(0, i));
//						else {
//							SBOLSynthesisNode cutNode = new SBOLSynthesisNode("cut" + idIndex);
//							idIndex++;
//							cutNode.setDNAComponents(dnaComps.subList(cutIndex, i));
//							cutNodes.add(cutNode);
//						}
//					else if (startTypes.contains(SBOLUtility.loadLowestSOTypes(dnaComps.get(i)).get(0))) {
//						if (cutIndex == 0) 
//							edgeComponents.addAll(dnaComps.subList(0, i));
//						else {
//							SBOLSynthesisNode cutNode = new SBOLSynthesisNode("cut" + idIndex);
//							idIndex++;
//							cutNode.setDNAComponents(dnaComps.subList(cutIndex, i));
//							cutNodes.add(cutNode);
//						}
//						cutIndex = i;
//					}
//				}
//				if (edgeComponents.size() > 0)
//					nextNode.setDNAComponents(edgeComponents);
//				else 
//					emptyEdgeNodes.add(nextNode);
//			}
//			synNode.getNextNodes().removeAll(emptyEdgeNodes);
//		}
//		for (SBOLSynthesisNode cutNode : cutNodes)
//			synMap.put(cutNode.getID(), cutNode);
//	}
	
	private void cutNodesWithStartComponents(Set<String> startTypes) {
		int idIndex = 0;
		Set<SBOLSynthesisNode> cutNodes = new HashSet<SBOLSynthesisNode>();
		Set<SBOLSynthesisNode> deletionNodes = new HashSet<SBOLSynthesisNode>();
		for (SBOLSynthesisNode synNode : synMap.values()) {
			Set<SBOLSynthesisNode> emptyNodes = new HashSet<SBOLSynthesisNode>();
			for (SBOLSynthesisNode nextNode : synNode.getNextNodes()) {
				List<Integer> cutIndices = new LinkedList<Integer>();
				List<DnaComponent> dnaComps = nextNode.getDNAComponents();
				for (int i = 0; i < dnaComps.size(); i++)
					if (startTypes.contains(SBOLUtility.loadLowestSOTypes(dnaComps.get(i)).get(0)))
						cutIndices.add(i);
				if (cutIndices.size() > 0) {
					cutIndices.add(dnaComps.size());
					for (int i = 0; i < cutIndices.size() - 1; i++) {
						SBOLSynthesisNode cutNode = new SBOLSynthesisNode("cut" + idIndex);
						cutNode.setDNAComponents(dnaComps.subList(cutIndices.get(i), cutIndices.get(i + 1)));
						idIndex++;
						if (i == cutIndices.size() - 2)
							cutNode.setNextNodes(nextNode.getNextNodes());
						cutNodes.add(cutNode);
					}
					List<DnaComponent> edgeComponents = dnaComps.subList(0, cutIndices.get(0));
					if (edgeComponents.size() > 0) {
						nextNode.setDNAComponents(edgeComponents);
						nextNode.setNextNodes(new LinkedList<SBOLSynthesisNode>());
					} else {
						emptyNodes.add(nextNode);
						deletionNodes.add(nextNode);
					}
				}
			}
			synNode.getNextNodes().removeAll(emptyNodes);
		}
		for (SBOLSynthesisNode cutNode : cutNodes)
			synMap.put(cutNode.getID(), cutNode);
		for (SBOLSynthesisNode deletionNode : deletionNodes)
			synMap.remove(deletionNode.getID());
	}
	
	private void selectStartNodes() {
		Set<String> nextIDs = new HashSet<String>();
		for (SBOLSynthesisNode synNode : synMap.values())
				for (SBOLSynthesisNode nextNode : synNode.getNextNodes())
					nextIDs.add(nextNode.getID());
		for (SBOLSynthesisNode synNode : synMap.values())
			if (!nextIDs.contains(synNode.getID())) {
				startNodes.add(synNode);
			}
	}
	
	private void cutCycles() {
		Set<String> globalNodeIDs = new HashSet<String>();
		for (SBOLSynthesisNode startNode : startNodes) {
			List<SBOLSynthesisNode> currentNodes = new LinkedList<SBOLSynthesisNode>();
			Set<String> visitedNodeIDs = new HashSet<String>();
			currentNodes.add(0, startNode);
			while (currentNodes.size() > 0) {
				visitedNodeIDs.add(currentNodes.get(0).getID());
				Set<SBOLSynthesisNode> cutNodes = new HashSet<SBOLSynthesisNode>();
				for (SBOLSynthesisNode nextNode : currentNodes.get(0).getNextNodes())
					if (visitedNodeIDs.contains(nextNode.getID()))
						cutNodes.add(nextNode);
				currentNodes.get(0).getNextNodes().removeAll(cutNodes);
				currentNodes.addAll(0, currentNodes.remove(0).getNextNodes());
			}
			globalNodeIDs.addAll(visitedNodeIDs);
		}
		if (globalNodeIDs.size() == synMap.size())
			isLinear = true;
	}
	
	public boolean containsSBOL() {
		return containsSBOL;
	}
	
	public boolean isLinear() {
		return isLinear;
	}
	
	public SBOLSynthesisNode getNode(String id) {
		return synMap.get(id);
	}
	
	public Set<SBOLSynthesisNode> getNodes() {
		return new HashSet<SBOLSynthesisNode>(synMap.values());
	}
	
	public Set<SBOLSynthesisNode> getStartNodes() {
		return startNodes;
	}
	
	public void print() {
		System.out.println("digraph G {");
		for (SBOLSynthesisNode synNode : synMap.values()) {
			String soTypes = "";
			for (DnaComponent dnaComp : synNode.getDNAComponents())
				for (String soType : SBOLUtility.loadLowestSOTypes(dnaComp))
					soTypes = soTypes + " " + soType;
			System.out.println(synNode.getID() + " [label=\"" + soTypes + "\"]");
			for (SBOLSynthesisNode nextNode : synNode.getNextNodes())
				System.out.println(synNode.getID() + " -> " + nextNode.getID());
		}
		System.out.println("}");
	}
}
